import 'dart:io';
import 'package:args/command_runner.dart';
import 'package:json2yaml/json2yaml.dart';
import 'package:pubspec_lock_parse/pubspec_lock_parse.dart';

import '../src/install_merge_driver.dart';
import '../src/merge_pubspec_locks.dart';

void main(List<String> args) {
  CommandRunner('pubspec_lock_merge_driver', 'automatically merges pubspec.lock file conflicts')
    ..addCommand(InstallCommand())
    ..addCommand(UninstallCommand())
    ..addCommand(MergeCommand())
    ..run(args);
}

class MergeCommand extends Command {
  @override
  final name = 'merge';

  @override
  final description = 'preforms the pubspec.lock merge';

  MergeCommand();

  Future<void> run() async {
    print('\x1B[33mWARN: A git conflict was detected in pubspec.lock. Attempting to auto-resolve.\x1B[0m');

    final args = argResults!.rest;
    if (args.length != 3) {
      print('error: exactly 3 pubspec.lock contents are required to run merge driver');
      exit(1);
    }

    final ours = args[0];
    final base = args[1];
    final theirs = args[2];

    try {
      final pubspecContentA = File(ours).readAsStringSync();
      final pubspecContentB = File(theirs).readAsStringSync();

      PubspecLock pubspecLockA;
      PubspecLock pubspecLockB;
      try {
        pubspecLockA = PubspecLock.parse(pubspecContentA);
        pubspecLockB = PubspecLock.parse(pubspecContentB);
      } catch (_) {
        throw _MergeCommandException('unable to parse provided pubspec files');
      }

      PubspecLock mergedLockfile;
      try {
        mergedLockfile = mergePubspecLocks(pubspecLockA, pubspecLockB);
      } on PubspecLockMergeException catch (e) {
        throw _MergeCommandException(e.reason);
      }

      final mergedLockfileContent = ('# Generated by pub\n'
          '# See https://dart.dev/tools/pub/glossary#lockfile\n'
          '${json2yaml(
        mergedLockfile.toJson(),
        yamlStyle: YamlStyle.pubspecLock,
      )}');

      File(ours).writeAsStringSync(mergedLockfileContent);

      exit(0);
    } on _MergeCommandException catch (e) {
      print('\x1B[31mERROR: Unable to merge lockfiles: "${e.reason}". Conflict(s) must be resolved manually.\x1B[0m');

      _runDefaultMerge(ours, base, theirs);
    } catch (e) {
      print('\x1B[31mERROR: Unable to merge lockfiles: Unknown Error\x1B[0m');
      print(e);
      print('\x1B[31mConflict(s) must be resolved manually.\x1B[0m');
      _runDefaultMerge(ours, base, theirs);
    }
  }

  Future<void> _runDefaultMerge(String ours, String base, String theirs) async {
    // utilize git's `git merge-file` command to default merging the lockfiles
    final defaultMerge = await Process.run('git', ['merge-file', '-p', ours, base, theirs]);
    File(ours).writeAsStringSync(defaultMerge.stdout.trim());

    // tell git to not commit the changes
    exit(1);
  }
}

class _MergeCommandException implements Exception {
  final String reason;
  _MergeCommandException(this.reason);
}

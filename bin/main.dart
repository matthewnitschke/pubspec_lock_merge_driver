import 'dart:io';
import 'package:args/command_runner.dart';
import 'package:json2yaml/json2yaml.dart';
import 'package:pubspec_lock_parse/pubspec_lock_parse.dart';

import '../src/install_merge_driver.dart';
import '../src/merge_pubspec_locks.dart';

void main(List<String> args) {
  CommandRunner('pubspec_lock_merge_driver', 'automatically merges pubspec.lock file conflicts')
    ..addCommand(InstallCommand())
    ..addCommand(UninstallCommand())
    ..addCommand(MergeCommand())
    ..run(args);
}

class MergeCommand extends Command {
  @override
  final name = 'merge';

  @override
  final description = 'preforms the pubspec.lock merge';

  MergeCommand();

  void run() {
    final args = argResults!.rest;

    print(args);

    if (args.length != 2) {
      stderr.writeln('error: exactly 2 pubspec.lock contents are required to run merge driver');
      exit(1);
    }

    final pubspecContentA = File(args.first).readAsStringSync();
    final pubspecContentB = File(args.last).readAsStringSync();

    PubspecLock pubspecLockA;
    PubspecLock pubspecLockB;
    try {
      pubspecLockA = PubspecLock.parse(pubspecContentA);
      pubspecLockB = PubspecLock.parse(pubspecContentB);
    } catch (_) {
      stderr.writeln('error: unable to parse provided pubspec files');
      exit(1);
    }

    PubspecLock mergedLockfile;
    try {
      mergedLockfile = mergePubspecLocks(pubspecLockA, pubspecLockB);
    } on PubspecLockMergeException catch (e) {
      stderr.writeln('error: unable to merge lockfiles: ${e.reason}');
      exit(1);
    } catch(e) {
      stderr.writeln('error: unable to merge lockfiles: ${e.toString()}');
      exit(1);
    }


    stdout.write(
      '# Generated by pub\n'
      '# See https://dart.dev/tools/pub/glossary#lockfile\n'
    );

    stdout.write(json2yaml(
      mergedLockfile.toJson(),
      yamlStyle: YamlStyle.pubspecLock,
    ));
  }
}